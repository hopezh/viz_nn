import * as THREE from "three";
import * as tf from "@tensorflow/tfjs";

export default class Util {
    // [+] reshape array (opt 1)
    static reshapeArr(_arr, shape) {
        let arr = _arr;
        // [ref] https://stackoverflow.com/a/69584753/3776170
        let elemIndex = 0;

        if (!shape || !arr) return [];

        function _nest(dimIndex) {
            let result = [];

            if (dimIndex === shape.length - 1) {
                result = result.concat(
                    arr.slice(elemIndex, elemIndex + shape[dimIndex])
                );
                elemIndex += shape[dimIndex];
            } else {
                for (let i = 0; i < shape[dimIndex]; i++) {
                    result.push(_nest(dimIndex + 1));
                }
            }

            return result;
        }
        return _nest(0);
    }

    // [+] reshape array (opt 2)
    // [-] the reshape function
    // note that the input "shape" doesn't include the last dimension
    // ...i.e. [2, 3], or [3], should be used,
    // ...instead of [2, 3, 2], or [3, 4], for a flattened array of 12 elements
    // prettier-ignore
    static reshapeArr2(arr, shape) { 
        if (shape.length < 1) 
            return arr;
        else
            return this.cut(arr, arr.length / shape[0])
            .map(
                (r) => this.reshapeArr2(r, shape.slice(1))
            );
    }

    // [-] the cut function
    // [ref] https://stackoverflow.com/a/69588900/3776170
    // prettier-ignore
    static cut(arr, n) {
        if (n >= arr.length) 
            return [arr];
        else 
            return [arr.slice(0, n), 
                    ...this.cut(arr.slice(n), n)
            ];
    }

    // [+] get array shape
    // [ref] https://stackoverflow.com/a/10253903/3776170
    static getShape(a) {
        var shape = [];
        for (;;) {
            shape.push(a.length);
            if (Array.isArray(a[0])) {
                a = a[0];
            } else {
                break;
            }
        }
        return shape;
    }

    // [+] get array size
    // [ref] https://stackoverflow.com/a/67578497/3776170
    static getSize(a) {
        var size = a.join(",").split(",").length;
        return size;
    }

    // [T] create 2D array from flat array
    // [ref] https://stackoverflow.com/questions/20257889/unflatten-arrays-into-groups-of-fours
    static arrayUnflatten(_flattenedArray, _numRows) {
        const len = _flattenedArray.length;

        const unflattenedArray = [];

        while (_flattenedArray.length > 0)
            unflattenedArray.push(_flattenedArray.splice(0, _numRows));

        return unflattenedArray;
    }

    static tensor3DToArr3D(_tensor3D) {
        const arr1D = [];

        for (let i = 0; i < _tensor3D.size; i++) {
            const item = _tensor3D.dataSync()[i];
            arr1D.push(item);
        }

        const tensor3DShape = _tensor3D.shape;
        // console.log(tensor3DShape);

        const arr3D = this.reshapeArr(arr1D, tensor3DShape);

        return arr3D;
    }

    /**
     * create a shape of rounded rectangle
     * @param {Number}  _x       x position of lower left corner
     * @param {Number}  _y       y position of lower left corner
     * @param {Number}  _width   width of rectangle
     * @param {Number}  _height  height of rectangle
     * @param {Number}  _radius  corner radius
     * @see {@link https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_shapes.html}
     */
    static rRectShape(_x, _y, _width, _height, _radius) {
        // [.] init an empty shape
        const shape = new THREE.Shape();

        // [.] draw rounded rectangle shape
        shape.moveTo(_x, _y + _radius);
        shape.lineTo(_x, _y + _height - _radius);
        shape.quadraticCurveTo(_x, _y + _height, _x + _radius, _y + _height);
        shape.lineTo(_x + _width - _radius, _y + _height);
        shape.quadraticCurveTo(
            _x + _width,
            _y + _height,
            _x + _width,
            _y + _height - _radius
        );
        shape.lineTo(_x + _width, _y + _radius);
        shape.quadraticCurveTo(_x + _width, _y, _x + _width - _radius, _y);
        shape.lineTo(_x + _radius, _y);
        shape.quadraticCurveTo(_x, _y, _x, _y + _radius);

        return shape;
    }

    static addShape(shape, color, x, y, z, rx, ry, rz, s) {
        // flat shape with texture
        // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices
        // let geometry = new THREE.ShapeGeometry(shape);
        // let mesh = new THREE.Mesh(
        //     geometry,
        //     new THREE.MeshPhongMaterial({
        //         side: THREE.DoubleSide,
        //         map: texture,
        //     })
        // );
        // mesh.position.set(x, y, z - 175);
        // mesh.rotation.set(rx, ry, rz);
        // mesh.scale.set(s, s, s);
        // group.add(mesh);

        // flat shape
        let geometry = new THREE.ShapeGeometry(shape);
        let mesh = new THREE.Mesh(
            geometry,
            new THREE.MeshPhongMaterial({
                color: color,
                side: THREE.DoubleSide,
                flatShading: true,
                shadowSide: THREE.DoubleSide,
            })
        );
        mesh.position.set(x, y, z);
        mesh.rotation.set(rx, ry, rz);
        mesh.scale.set(s, s, s);
        // mesh.castShadow = true;
        // mesh.receiveShadow = true;

        return mesh;

        // extruded shape
        // geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        // mesh = new THREE.Mesh(
        //     geometry,
        //     new THREE.MeshPhongMaterial({ color: color })
        // );
        // mesh.position.set(x, y, z - 75);
        // mesh.rotation.set(rx, ry, rz);
        // mesh.scale.set(s, s, s);
        // group.add(mesh);

        // addLineShape(shape, color, x, y, z, rx, ry, rz, s);
    }

    static highlightCard(x, y, z, _x, _y, _z, _i, _matrix, _instancedMeshes) {
        if (z == _z && y == _y && x == _x) {
            // matrix element by default is column major,
            // ... so need to use tf.transpose to convert it into row major matrix
            const translation_matrix_row_major = tf.transpose(
                tf.tensor(_matrix.elements, [4, 4])
            );

            console.log(
                "translation matrix of item ",
                _i + 1,
                "is (row major):"
            );
            translation_matrix_row_major.print();
            // ref on translation matrix
            // http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/

            let highlight_color = new THREE.Color();
            highlight_color.setHex(0x000000);
            _instancedMeshes.setColorAt(_i, highlight_color);
            // _instancedMeshes[_i].opacity = 0.2;
        }
    }
}
